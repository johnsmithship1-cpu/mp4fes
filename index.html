<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Rhythm Game - Sukufesu Style</title>
    <!-- Google Fonts for Richer Typography -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Outfit:wght@400;700&display=swap"
        rel="stylesheet">

    <style>
        :root {
            --bg-color: #0f0c29;
            --primary: #24243e;
            --accent: #00d2ff;
            --accent-glow: rgba(0, 210, 255, 0.5);
            --text-color: #ffffff;
            --perfect: #ffeb3b;
            --great: #8bc34a;
            --good: #03a9f4;
            --miss: #f44336;
            --font-main: 'Outfit', sans-serif;
            --font-display: 'Orbitron', sans-serif;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: var(--font-main);
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }

        #app {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            max-width: 900px;
            max-height: 500px;
            background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.5);
            overflow: hidden;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 5;
            pointer-events: auto;
        }

        #game-video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: 2;
            display: none;
            opacity: 0.6;
        }

        #game-video.visible {
            display: block;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
        }

        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            background: rgba(15, 12, 41, 0.8);
            backdrop-filter: blur(10px);
        }

        .screen.active {
            display: flex;
        }

        #hud {
            background: transparent;
            backdrop-filter: none;
            pointer-events: none;
        }

        /* Typography */
        .game-title {
            font-family: var(--font-display);
            font-size: 3.5rem;
            font-weight: 900;
            text-align: center;
            color: var(--accent);
            text-shadow: 0 0 20px var(--accent-glow), 0 0 40px var(--accent);
            margin-bottom: 2rem;
            letter-spacing: 5px;
            line-height: 1;
        }

        .upload-section {
            margin: 1.5rem 0;
            text-align: center;
            position: relative;
            z-index: 10;
            background: rgba(255, 255, 255, 0.05);
            padding: 1.5rem;
            border-radius: 15px;
            width: 100%;
            max-width: 400px;
        }

        .upload-btn {
            display: inline-block;
            padding: 0.8rem 2rem;
            background: rgba(255, 255, 255, 0.1);
            border: 1px dashed var(--accent);
            color: var(--accent);
            font-family: var(--font-display);
            border-radius: 10px;
            cursor: pointer;
            margin-bottom: 0.5rem;
            transition: all 0.3s;
        }

        .upload-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            box-shadow: 0 0 15px var(--accent-glow);
        }

        #file-name {
            display: block;
            font-size: 0.8rem;
            opacity: 0.6;
        }

        /* Buttons */
        .action-btn {
            font-family: var(--font-display);
            background: linear-gradient(45deg, var(--accent), #3a7bd5);
            border: none;
            padding: 1rem 3rem;
            color: white;
            font-size: 1.5rem;
            font-weight: bold;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            transition: transform 0.2s, box-shadow 0.2s, filter 0.2s;
        }

        .action-btn:active {
            transform: scale(0.95);
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.3);
        }

        .action-btn:hover {
            filter: brightness(1.2);
        }

        .back-btn {
            background: transparent;
            border: 2px solid white;
            padding: 0.5rem 2rem;
            color: white;
            margin-top: 1rem;
            border-radius: 25px;
            cursor: pointer;
            font-family: var(--font-display);
        }

        /* HUD Components */
        .score-container {
            position: absolute;
            top: 20px;
            right: 20px;
            text-align: right;
            font-family: var(--font-display);
        }

        .label {
            font-size: 0.8rem;
            opacity: 0.8;
            letter-spacing: 2px;
        }

        .combo-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -100%);
            text-align: center;
            opacity: 0;
            transition: opacity 0.2s;
            font-family: var(--font-display);
        }

        .combo-container.visible {
            opacity: 1;
        }

        #combo-val {
            font-size: 2.5rem;
            /* Reduced size */
            font-weight: 900;
            color: var(--accent);
            text-shadow: 0 0 20px var(--accent-glow), 2px 2px 0px rgba(0, 0, 0, 0.5);
            line-height: 1;
        }

        #score-val {
            font-size: 2rem;
            font-weight: 700;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
        }

        #judgment-text {
            position: absolute;
            top: 60%;
            left: 50%;
            transform: translate(-50%, 0);
            font-family: var(--font-display);
            font-size: 1.8rem;
            font-weight: 900;
            text-transform: uppercase;
            text-shadow: 0 0 15px currentColor;
            letter-spacing: 3px;
        }

        /* Result Screen Stats */
        .result-stats {
            width: 80%;
            max-width: 400px;
            margin-bottom: 2rem;
            font-family: var(--font-display);
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            padding: 0.5rem 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 1.2rem;
        }

        .stat-total {
            display: flex;
            justify-content: space-between;
            padding: 1rem 0;
            font-size: 1.8rem;
            font-weight: bold;
            color: var(--accent);
            text-shadow: 0 0 10px var(--accent-glow);
            margin-top: 1rem;
            border-top: 2px solid var(--accent);
        }

        /* Debug log removed */
    </style>
    <link rel="manifest" href="manifest.json">
</head>

<body>
    <div id="app">
        <div id="game-container">
            <!-- Debug log removed -->
            <canvas id="game-canvas"></canvas>

            <div id="ui-layer">
                <!-- Main Menu -->
                <div id="menu-screen" class="screen active">
                    <h1 class="game-title">RHYTHM<br>STATION</h1>
                    <button id="start-btn" class="action-btn">GAME START</button>
                </div>

                <!-- Song Selection -->
                <div id="song-selection-screen" class="screen">
                    <h2>SONG SELECT</h2>
                    <div class="song-list">
                        <div class="song-item active" data-song="tutorial">
                            <div class="song-info">
                                <span class="song-name">Auto Gen Meta</span>
                                <span class="song-difficulty">DYNAMIC</span>
                            </div>
                        </div>
                    </div>
                    <div class="upload-section">
                        <label for="video-upload" class="upload-btn">SELECT MP4</label>
                        <input type="file" id="video-upload" accept="video/mp4" style="display: none;">
                        <span id="file-name">No file selected</span>
                    </div>
                    <button id="back-to-menu" class="back-btn">BACK</button>
                    <button id="play-btn" class="action-btn">PLAY</button>
                </div>

                <!-- Gameplay UI -->
                <div id="hud" class="screen">
                    <div class="score-container">
                        <div class="label">SCORE</div>
                        <div id="score-val">0000000</div>
                    </div>
                    <div class="combo-container">
                        <div id="combo-val">0</div>
                        <div class="label">COMBO</div>
                    </div>
                    <div id="judgment-text"></div>
                </div>

                <!-- Result Screen -->
                <div id="result-screen" class="screen">
                    <h2>RESULT</h2>
                    <div class="result-stats">
                        <div class="stat-item"><span>PERFECT</span><span id="res-perfect">0</span></div>
                        <div class="stat-item"><span>GREAT</span><span id="res-great">0</span></div>
                        <div class="stat-item"><span>GOOD</span><span id="res-good">0</span></div>
                        <div class="stat-item"><span>MISS</span><span id="res-miss">0</span></div>
                        <div class="stat-total"><span>TOTAL SCORE</span><span id="res-score">0</span></div>
                    </div>
                    <button id="restart-btn" class="action-btn">RETRY</button>
                    <button id="quit-btn" class="back-btn">MENU</button>
                </div>
            </div>

            <video id="game-video" playsinline></video>
        </div>
    </div>

    <script>
        // onerror handler removed (or just console log)
        window.onerror = function (msg, url, line, col, error) {
            console.error(`ERR: ${msg} at ${line}:${col}`);
            return false;
        };

        class GameEngine {
            constructor() {
                try {
                    this.canvas = document.getElementById('game-canvas');
                    this.ctx = this.canvas.getContext('2d');
                    this.gameState = 'menu';
                    this.score = 0;
                    this.combo = 0;
                    this.maxCombo = 0;
                    this.notes = [];
                    this.targetPoints = [];
                    this.numTargets = 6;
                    this.lastTime = 0;
                    this.startTime = 0;
                    this.isPlaying = false;
                    this.stats = { perfect: 0, great: 0, good: 0, miss: 0 };

                    // Audio
                    this.audioCtx = null;
                    this.analyser = null;
                    this.video = document.getElementById('game-video');
                    this.currentFile = null;
                    this.tapSoundBuffer = null;
                    this.tapSoundAudio = null;

                    // Input Tracking
                    this.activeTouches = new Map();

                    // Analysis
                    this.lastAnalysisTime = 0;
                    this.beatThreshold = 140;
                    this.minBeatInterval = 400;
                    this.lastEnergy = 0;

                    this.init();
                } catch (e) { console.error(e); }
            }

            init() {
                this.log("Initializing...");
                this.resize();
                window.addEventListener('resize', () => this.resize());
                this.setupTargets();
                this.bindEvents();
                this.renderLoop();
            }

            log(msg) {
                console.log("[RhythmGame] " + msg);
            }

            initAudio() {
                if (this.audioCtx) return;
                this.log("Init Audio...");
                try {
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    this.audioCtx = new AudioContext();
                    this.analyser = this.audioCtx.createAnalyser();
                    this.analyser.fftSize = 256;
                    this.video.crossOrigin = "anonymous";
                    this.source = this.audioCtx.createMediaElementSource(this.video);
                    this.source.connect(this.analyser);
                    this.analyser.connect(this.audioCtx.destination);
                    this.loadTapSound();
                    this.log("Audio OK");
                } catch (e) {
                    this.log("Audio fail: " + e.message);
                }
            }

            loadTapSound() {
                try {
                    const audio = new Audio('SleighBells.mp3');
                    audio.addEventListener('canplaythrough', () => {
                        this.tapSoundAudio = audio;
                        this.log("Tap sound loaded");
                    });
                    audio.load();
                } catch (e) {
                    this.log("Tap sound error: " + e.message);
                }
            }

            playTapSound() {
                if (!this.audioCtx) return;
                if (this.tapSoundAudio) {
                    try {
                        const audio = this.tapSoundAudio.cloneNode();
                        audio.volume = 1.0;
                        audio.play().catch(e => { });
                        return;
                    } catch (e) { }
                }
            }

            resize() {
                const container = document.getElementById('game-container');
                this.canvas.width = container.clientWidth;
                this.canvas.height = container.clientHeight;
                this.setupTargets();
            }

            setupTargets() {
                this.targetPoints = [];
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height * 0.2;
                const radius = Math.min(this.canvas.width, this.canvas.height) * 0.7;
                const colors = ['#2196F3', '#9C27B0', '#F44336', '#E91E63', '#FFEB3B', '#4CAF50'];
                for (let i = 0; i < this.numTargets; i++) {
                    const angle = Math.PI + (Math.PI / (this.numTargets - 1)) * i;
                    this.targetPoints.push({
                        x: centerX + Math.cos(angle) * radius,
                        y: centerY - Math.sin(angle) * radius,
                        color: colors[i]
                    });
                }
            }

            bindEvents() {
                document.getElementById('start-btn').onclick = () => {
                    this.initAudio();
                    this.switchScreen('song-select');
                };
                document.getElementById('back-to-menu').onclick = () => {
                    if (this.video) { this.video.pause(); this.video.currentTime = 0; }
                    this.switchScreen('menu');
                };
                document.getElementById('play-btn').onclick = () => {
                    if (this.currentFile) this.startGame();
                    else alert('Please select MP4');
                };
                document.getElementById('restart-btn').onclick = () => this.startGame();
                document.getElementById('quit-btn').onclick = () => this.switchScreen('menu');

                const upload = document.getElementById('video-upload');
                upload.onchange = (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        this.currentFile = file;
                        document.getElementById('file-name').innerText = file.name;
                        this.video.src = URL.createObjectURL(file);
                        this.video.load();
                    }
                };

                const canvas = this.canvas;
                canvas.addEventListener('touchstart', (e) => this.handleTouchStart(e), { passive: false });
                canvas.addEventListener('touchmove', (e) => this.handleTouchMove(e), { passive: false });
                canvas.addEventListener('touchend', (e) => this.handleTouchEnd(e), { passive: false });
                canvas.addEventListener('touchcancel', (e) => this.handleTouchEnd(e), { passive: false });

                canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));
            }

            switchScreen(screenName) {
                this.gameState = screenName;
                document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
                let sid = screenName + '-screen';
                if (screenName === 'playing') sid = 'hud';
                if (screenName === 'song-select') sid = 'song-selection-screen';
                document.getElementById(sid)?.classList.add('active');
                this.isPlaying = (screenName === 'playing');
            }

            startGame() {
                this.initAudio();
                if (this.audioCtx.state === 'suspended') this.audioCtx.resume();
                this.score = 0; this.combo = 0; this.maxCombo = 0;
                this.notes = [];
                this.stats = { perfect: 0, great: 0, good: 0, miss: 0 };
                this.activeTouches.clear();
                this.updateHUD();
                this.switchScreen('playing');

                this.video.classList.add('visible');
                this.video.currentTime = 0;
                this.video.volume = 0.5;
                this.video.play().catch(e => this.log("Play err: " + e.message));

                this.startTime = performance.now();
                this.lastAnalysisTime = 0;
            }

            spawnNote() {
                const spawnTime = performance.now() - this.startTime;
                const duration = 1500;
                const rand = Math.random();

                const getRandomTarget = (exclude = []) => {
                    let idx;
                    do { idx = Math.floor(Math.random() * this.numTargets); } while (exclude.includes(idx));
                    return idx;
                };

                // No long notes, only normal (80%) or simultaneous (20%)
                if (rand < 0.2) {
                    const t1 = getRandomTarget();
                    const t2 = getRandomTarget([t1]);
                    this.addNote(t1, spawnTime, duration, 'normal', 0, true);
                    this.addNote(t2, spawnTime, duration, 'normal', 0, true);
                } else {
                    const t = getRandomTarget();
                    this.addNote(t, spawnTime, duration, 'normal');
                }
            }

            addNote(targetIdx, spawnTime, duration, type, holdDuration = 0, isSimultaneous = false) {
                this.notes.push({
                    targetIdx, spawnTime, duration, type, holdDuration,
                    isSimultaneous,
                    isHolding: false,
                    processed: false
                });
            }

            // Input Handling
            getHitTargetIdx(cx, cy) {
                const rect = this.canvas.getBoundingClientRect();
                const x = cx - rect.left;
                const y = cy - rect.top;
                let closest = -1;
                let minDist = 70;
                this.targetPoints.forEach((pt, i) => {
                    const d = Math.sqrt((x - pt.x) ** 2 + (y - pt.y) ** 2);
                    if (d < minDist) { minDist = d; closest = i; }
                });
                return closest;
            }

            handleTouchStart(e) {
                e.preventDefault();
                for (let i = 0; i < e.changedTouches.length; i++) {
                    const t = e.changedTouches[i];
                    const idx = this.getHitTargetIdx(t.clientX, t.clientY);
                    if (idx !== -1) {
                        this.activeTouches.set(t.identifier, idx);
                        this.checkHit(idx);
                    }
                }
            }

            handleTouchMove(e) {
                e.preventDefault();
                for (let i = 0; i < e.changedTouches.length; i++) {
                    const t = e.changedTouches[i];
                    const idx = this.getHitTargetIdx(t.clientX, t.clientY);
                    const prev = this.activeTouches.get(t.identifier);
                    if (idx !== -1 && idx !== prev) {
                        this.activeTouches.set(t.identifier, idx);
                    } else if (idx === -1) {
                        this.activeTouches.delete(t.identifier);
                    }
                }
            }

            handleTouchEnd(e) {
                e.preventDefault();
                for (let i = 0; i < e.changedTouches.length; i++) {
                    this.activeTouches.delete(e.changedTouches[i].identifier);
                }
            }

            handleMouseDown(e) {
                const idx = this.getHitTargetIdx(e.clientX, e.clientY);
                if (idx !== -1) {
                    this.activeTouches.set('mouse', idx);
                    this.checkHit(idx);
                }
            }
            handleMouseMove(e) {
                const idx = this.getHitTargetIdx(e.clientX, e.clientY);
                if (idx !== -1 && this.activeTouches.has('mouse')) {
                    this.activeTouches.set('mouse', idx);
                } else if (idx === -1) {
                    this.activeTouches.delete('mouse');
                }
            }
            handleMouseUp(e) {
                this.activeTouches.delete('mouse');
            }

            isTargetHeld(idx) {
                for (let val of this.activeTouches.values()) {
                    if (val === idx) return true;
                }
                return false;
            }

            checkHit(targetIdx) {
                if (!this.isPlaying) return;
                const now = performance.now() - this.startTime;

                let found = null;
                let minDiff = Infinity;

                for (let note of this.notes) {
                    if (note.targetIdx === targetIdx && !note.processed) {
                        const arrTime = note.spawnTime + note.duration;
                        const diff = Math.abs(now - arrTime);
                        if (diff < 150 && diff < minDiff) {
                            minDiff = diff; found = note;
                        }
                    }
                }

                if (found) {
                    let j = 'MISS';
                    if (minDiff < 50) j = 'PERFECT';
                    else if (minDiff < 100) j = 'GREAT';
                    else j = 'GOOD';

                    found.processed = true;
                    this.applyJudgment(j);
                }
            }

            applyJudgment(j, countStats = true) {
                this.showJudgment(j);
                if (j === 'MISS') {
                    this.combo = 0;
                    if (countStats) this.stats.miss++;
                } else {
                    this.playTapSound();
                    this.combo++;
                    this.maxCombo = Math.max(this.combo, this.maxCombo);
                    let score = 500;
                    if (j === 'PERFECT') { score = 1000; if (countStats) this.stats.perfect++; }
                    else if (j === 'GREAT') { score = 750; if (countStats) this.stats.great++; }
                    else { if (countStats) this.stats.good++; }
                    this.score += score + this.combo * 10;
                }
                this.updateHUD();
            }

            updateHUD() {
                document.getElementById('score-val').innerText = String(this.score).padStart(7, '0');
                document.getElementById('combo-val').innerText = this.combo;
                document.querySelector('.combo-container').classList.toggle('visible', this.combo > 0);
            }

            showJudgment(text) {
                const el = document.getElementById('judgment-text');
                el.innerText = text;
                el.style.color = `var(--${text.toLowerCase()})`;
                el.style.animation = 'none';
                el.offsetHeight;
                el.style.animation = null;
            }

            renderLoop(t) {
                try {
                    this.update(t);
                    this.draw();
                    requestAnimationFrame(t => this.renderLoop(t));
                } catch (e) {
                    this.log("Render: " + e.message);
                }
            }

            update(t) {
                if (!this.isPlaying) return;
                const now = t - this.startTime;

                if (this.analyser) {
                    const data = new Uint8Array(this.analyser.frequencyBinCount);
                    this.analyser.getByteFrequencyData(data);
                    let energy = 0; for (let i = 0; i < 5; i++) energy += data[i];
                    energy /= 5;
                    const diff = energy - this.lastEnergy;
                    if (energy > this.beatThreshold && diff > 5 && now - this.lastAnalysisTime > this.minBeatInterval) {
                        this.spawnNote();
                        this.lastAnalysisTime = now;
                    }
                    this.lastEnergy = energy;
                }

                this.notes.forEach(note => {
                    if (note.processed) return;
                    const arrTime = note.spawnTime + note.duration;

                    if (now > arrTime + 150) {
                        note.processed = true;
                        this.applyJudgment('MISS');
                    }
                });

                this.notes = this.notes.filter(n => !n.processed || (now - (n.spawnTime + n.duration) < 1000));

                if (this.video.ended) this.endGame();
            }

            endGame() {
                this.isPlaying = false;
                this.video.pause();
                this.video.classList.remove('visible');
                document.getElementById('res-perfect').innerText = this.stats.perfect;
                document.getElementById('res-great').innerText = this.stats.great;
                document.getElementById('res-good').innerText = this.stats.good;
                document.getElementById('res-miss').innerText = this.stats.miss;
                document.getElementById('res-score').innerText = this.score;
                this.switchScreen('result');
            }

            draw() {
                try {
                    const { ctx, canvas } = this;
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height * 0.2;

                    // Targets
                    this.targetPoints.forEach((pt, idx) => {
                        ctx.beginPath();
                        ctx.arc(pt.x, pt.y, 40, 0, Math.PI * 2);
                        ctx.strokeStyle = pt.color; ctx.lineWidth = 3; ctx.stroke();

                        ctx.beginPath();
                        ctx.arc(pt.x, pt.y, 35, 0, Math.PI * 2);
                        ctx.fillStyle = this.isTargetHeld(idx) ? pt.color + '88' : pt.color + '33';
                        ctx.fill();
                    });

                    if (this.isPlaying) {
                        const now = performance.now() - this.startTime;

                        // Draw Notes
                        this.notes.forEach(note => {
                            if (note.processed) return;
                            this.drawHead(note, now, centerX, centerY);
                        });
                    }
                } catch (e) {
                    console.error("Draw error", e);
                    throw e;
                }
            }

            getNotePos(note, now, cx, cy) {
                const elapsed = now - note.spawnTime;
                const prog = elapsed / note.duration;
                const target = this.targetPoints[note.targetIdx];
                const x = cx + (target.x - cx) * prog;
                const y = cy + (target.y - cy) * prog;
                return { x, y, progress: prog, color: target.color };
            }

            drawHead(note, now, cx, cy) {
                let pos;
                const target = this.targetPoints[note.targetIdx];
                pos = this.getNotePos(note, now, cx, cy);

                const elapsed = now - note.spawnTime;
                const prog = elapsed / note.duration;
                if (prog > 1.2) return;

                this.ctx.beginPath();
                this.ctx.arc(pos.x, pos.y, 30, 0, Math.PI * 2);

                this.ctx.lineWidth = 5;
                this.ctx.strokeStyle = pos.color;
                this.ctx.stroke();

                if (note.isSimultaneous) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(pos.x - 20, pos.y);
                    this.ctx.lineTo(pos.x + 20, pos.y);
                    this.ctx.lineWidth = 5;
                    this.ctx.strokeStyle = pos.color;
                    this.ctx.stroke();
                }
            }
        }
        window.onload = () => { window.game = new GameEngine(); };
        if ('serviceWorker' in navigator) navigator.serviceWorker.register('./sw.js');
    </script>
</body>

</html>
